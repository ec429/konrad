KONRAD - Kerbal Operations, Naughty Rockets, Aerial Debris

A telemachus control panel with a retro feel.  Built on curses technology.

License
-------
KONRAD is licensed under the GNU General Public License version 2,
incorporated herein by reference.

Dependencies
------------
* Python
  - tested with 2.7.11 but should work on any 2.6 or later
  - doesn't work with Python3 yet
* curses
* websocket-client, https://pypi.python.org/pypi/websocket-client/
  - can be found in Debian package "python-websocket"
* Telemachus, https://github.com/richardbunt/Telemachus

Consoles
--------
konrad.py must always be run with a 'consname' argument, indicating which
console it should display.  So far we have the following:
* fd
    Flight Director.  Summarises key vehicle state.
    Inputs:
    - t/r/b/g for SAS/RCS/BRK/GEAR
    - space for staging
    - 1-9 and 0 for action groups
    - ! (shift-1) for Abort!  (NOTE!  Not the same key as in KSP!)
* traj
    Trajectory.  The guy who's steering probably wants this one.  If you want
    remote control, pass option --mj to enable MechJeb commands
    Pass option --target-alt or both of --target-apo and --target-peri to get
    nice FractionGauges.  Note: --target-alt=X does not mean the same thing
    as --target-apo=X --target-peri=X; the former will have a target velocity
    of the Vcirc at altitude X, while the latter will have a target velocity
    dependent on your current altitude (determined from vis-viva equation),
    just like it would if target apo and target peri were different.
    Inputs: < (retrograde) and > (prograde) control AoA gauge behaviour.  The
    rest are MechJeb commands:
    - P/R to select (orbital) Prograde or Retrograde hold
    - O/I to select Radial Plus ('O'utward) or Minus ('I'nward)
    - +/- to select Normal Plus or Minus
    - Enter to select Fixed (uses the Input Orientation PIT/HDG/RLL)
    - s/w to change Input PIT by ±10°; S/W for ±1°
    - d/a to change Input HDG by ±10°; D/A for ±1°
    - e/q to change Input RLL by ±10°; E/Q for ±1°
    - ? to copy current Orientation into Input Orientation
    A warning about Fixed mode: while the controls may appear to be the same
    as in-game, *they are not*!  For instance, if you are rolled 90° right,
    pressing 's' in KONRAD will effectively yaw left (same as pressing 'a' in-
    game), as that is what is required to increase your pitch.
* boost
    Booster.  Track remaining fuel and delta-V.
    Requires an accurate JSON Booster file, supplied with --booster.  See the
    section "JSON Booster" below for more information.
    Inputs:
    - x to cut throttle
    - 1-9 for 10-90% throttle
    - z for 100% throttle
    - space for staging
* retro
    Retrograde Guidance.  For judging landings on airless bodies.
    See section "Landings" below for more information.
    Pass option --ground-map=<csvfile> to supply a SCANsat CSV map of ground
    elevation, or --ground-alt=<altitude> to assume a fixed value.
    Pass option -b <body-id> for the body you're landing on.
    Requires an accurate JSON Booster file, supplied with --booster.  See the
    section "JSON Booster" below for more information.
    Inputs:
    - f to select 'Fixed' mode (assume vehicle holds current pitch)
    - r to select 'Retro' mode (assume retrograde hold)
    - PgUp/PgDn to increment/decrement Reserved Stages
    - x to cut throttle
    - 1-9 for 10-90% throttle
    - z for 100% throttle
    - space for staging
* asc
    Ascent Guidance.  For judging launches to orbit (ignores air drag).
    See section "Ascent Guidance" below for more information.
    Requires an accurate JSON Booster file, supplied with --booster.  See the
    section "JSON Booster" below for more information.
    Inputs:
    - f to select 'Fixed' mode (assume vehicle holds current pitch)
    - p to select 'Progd' mode (assume prograde hold)
    - PgUp/PgDn to increment/decrement Reserved Stages
    - x to cut throttle
    - 1-9 for 10-90% throttle
    - z for 100% throttle
    - space for staging

Global Inputs
-------------
The following inputs are recognised by any console:
- Ctrl-X to exit
- (/) to select prev/next body

Useful Notes
------------
There are two kinds of FractionGauge: Mode 3 and Mode 2.  (Naturally.)
Mode 3 gauges simply fill up from left to right, mostly green, with red and
yellow denoting a 1/3 and 2/3 filled block respectively.  They are used either
where an overshoot is physically impossible (e.g. >100% fuel reserve) or for
angle gauges, where the values wrap around (and may become negative; these
gauges will use the absolute value in this situation).
Mode 2 gauges are used when there is an (implicit or explicit) target for the
value being displayed (e.g. altitude, apsides or velocity).  These gauges also
fill up with green, with yellow denoting a 1/2 block.  However, once they
overshoot the target, they 'bounce off' the end in red.  So a bar 3/4 green and
the rest red indicates a value 125% of the target.

Because Telemachus won't give us the bodyID (only its name), KONRAD has to be
told it by the user (-b option, defaults to 1).  If the current body name does
not match the name retrieved for the bodyID, KONRAD will warn the user, showing
a value of <current>!<expected> in the BodyGauge (and pushing a "Change Body"
message to the status line).  In this situation, calculated values such as the
target orbital velocity will be bogus.

JSON Booster
------------
A way of telling KONRAD some things about your rocket that it can't get from
the telemetry.  The information is specified in JSON format, according to the
following layout:
The top-level item is a Booster, which consists of a list of Stages.
A Stage is a dictionary, with the following items:
  "props": list of Propellants
  "isp": main engine Isp in seconds
  "dry": stage dry mass in tons
Two further items can optionally be specified; they are used only by the Retro
and Ascent consoles:
  "thrust": main engine thrust in kN
  "minThrottle": main engine minimum throttle setting in percent
A Propellant is a dictionary, with the following items:
  "name": the KSP resource name of the propellant
  "volume": the volume of the tank (this is in litres if using RealismOverhaul)
  "density": the propellant density.  Look in resource files for this
  "mainEngine": optional boolean (defaults to true) indicating whether this
                 propellant is consumed by the main engine (and is thus part of
                 the interpretation of the Isp figure)
Some examples are in the jb_examples/ directory:
* WAC.  Three TinyTim boosters and an Aerobee sustainer.
* AtlasAgena.  An Agena-D (with hydrazine RCS) on an Atlas SLV-3.  This example
   exhibits one of the main limitations of the format: it can't comprehend
   Atlas-style parallel staging.  But that's OK, because there's no way for us
   to figure out from the telemetry whether the booster engines have been
   dropped _anyway_, as Telemachus won't give us staging information directly -
   we have to deduce it by noticing that tanks have been dropped, which of
   course doesn't work for Atlas.  (However, it turns out that the booster
   engines have TEATEB tanks, meaning that we _can_ detect the staging event.)
* MercuryAtlas.  An example of how to make parallel staging work, based on
   FASA's Mercury and Atlas parts.  Note how (a) the sustainer propellants are
   listed under the third stage, even though they're in the same tank as the
   others; (b) the TEATEB tanks on the LR-89 booster engines are used to detect
   when those engines are dropped; (c) the escape tower is treated as dead
   weight because in a nominal launch it will be jettisoned rather than fired.
   The delta-V for the booster stage will be a slight underestimate, because
   the concurrent sustainer burn is at a higher Isp; strictly speaking we
   should use an average Isp weighted by fuel flow rate, but this would be very
   close to the booster engine Isp, so the errors should be small.

As it's somewhat annoying to have to work out all these values (particularly
 the dry masses), it would be nice to have a way to export a JSON Booster
 specification from the game.  That's something I plan to look into in the
 not-too-distant future.  (Unfortunately, the tricks we use for Atlas would
 still need to be done by hand.)
You can, however, avoid having to look up all the densities: just set the
 environment variable KSPPATH to point at your KSP top-level directory, and
 KONRAD will read GameData/ModuleManager.ConfigCache to find them out.  That
 way, you can leave the "density" key out of Propellant specifications.

Landings
--------
The Retro console may seem rather intimidating at first, with its large array
of poorly-labelled numbers.  But don't panic, the layout is very logical and
it's quite simple to use.  The first thing to notice is that there are two
blocks with similar layout, for "At current throttle" and "At 100% throttle".
This is so that you know if full throttle suffices to prevent lithobraking.
Now, for each of those two throttle settings, KONRAD will run a simulation.
It will assume either that you maintain your current pitch (Fixed mode) or
that you hold surface retrograde (Retro mode), and that your heading is that
corresponding to surface retrograde.  This simulation takes into account the
decreasing mass of your craft as propellants are burned, the curvature of the
target body, etc.  There are four 'events' of interest which the simulation
will record:
* Horizontal - the horizontal component of velocity becomes zero.  (If using
  Fixed mode, from this point the sim will assume a pitch of 90°.)
* Vertical - the vertical component of velocity becomes zero.
* Surface - the altitude above terrain becomes zero.
* Burnout - the vehicle is emptied of all propellants.  (If your vehicle has a
  separate ascent stage, like the Apollo LEM, you can use 'Rsvd.Stg.' - i.e.
  reserved stages - to exclude it, so that this event correctly shows burnout
  of the descent stage.)
For each of these events, various parameters are recorded, a selection of
which are displayed (different for each event).
T: time after simulation start
Y: altitude above terrain
X: distance downrange from simulation start
V: vertical speed (upwards positive)
H: horizontal speed
The various displayed numbers will mostly be coloured red or green to tell you
whether they are bad or good news.  For instance, if Vertical Y is negative,
this means you won't stop descending before you hit the ground, which is Bad.
There's also 'Touchdown' - which is 'Surface' if it happens, 'Horizontal'
otherwise - at which the latitude and longitude are recorded.  These can be
used for targeting a specific landing site.

So how does one use this information?  Assuming you're on a sub-orbital
trajectory, point retrograde, select Fixed mode, look at the "full throttle"
output, then increase pitch until Vertical Y is green (positive).  Check that
Burnout T is green (greater than Surface T) - if not, you'll run out of fuel
before landing at this rate, which probably means you need to wait a while and
descend further before running the engine.
Check that Horizontal T is green (less than Vertical T) - if not, you need to
point at a higher pitch to increase the time you have for
horizontal braking.
Assuming everything's green, throttle up to 100% and watch the descent.  The
numbers should all remain roughly constant, except that X decreases and T
counts down.
Wait until your retrograde marker passes through your current pitch (i.e.
you're descending more steeply than you're pointing).  At this point, switch
your SAS to Retrograde Hold, and switch KONRAD into Retro mode (by pressing
'r').  You should find that the board is still green (except maybe for
Horizontal T, which should now be equal to Vertical T), but that Vertical Y is
now rather larger than it was.  Throttle down until Vertical Y is only just
above zero - you want to aim for about 40 metres.  (At this point you may need
to start making an adjustment for errors in your terrain map.  This is because
unfortunately SCANsat maps only have ½° resolution, which does not always
capture enough terrain detail on a cratered moon.  You also, of course, need
to start looking at the "At current throttle" board.)
Once your vertical speed is suitably low, throttle back further; try and keep
your Vertical Y at a few seconds' descent above the surface.  Once you're
descending vertically at a good landing speed, throttle back to bring your TWR
as close to 1 as you can.  After a few more seconds you should touch down
gently on the surface; cut your engine, sit back, and relax.  Congratulations,
you've landed!

Ascent Guidance
---------------
The Ascent console is based on the same principle as Retro, namely running a
simulation based on certain assumptions, and recording motion parameters at
various events.  The AscentSim recognises three events:
* Orb-Vel - the horizontal component of velocity reaches the velocity for a
  circular orbit at the current altitude.
* Vertical - the vertical component of velocity becomes zero.
* Burnout - the vehicle is emptied of all propellants, excluding any reserved
  stages.
Because the AscentSim ignores atmospheric drag, it won't be useful until the
air thins out.  On the other hand, you won't have much freedom to steer
anyway while in thick air, because aerodynamic forces will destroy a rocket
that doesn't stick pretty closely to a gravity turn.  (Judging the pitch kick
to start your gravity turn is a separate problem, which AscentSim can't help
you with.  Try running some simulations in Kerbal Construction Time.)
If you just want to reach a circular orbit, and don't care too much about the
altitude, select Fixed mode and aim to get Orb-Vel V close to zero.  This
means that on reaching orbital velocity, your vertical speed will be zero, so
you will be in a circular orbit at that altitude.
Conveniently, the Orb-Vel section also displays altitude (Y), so if you want
to target a specific (circular) orbit, you can aim either above or below the
angle for circularisation to slowly 'pull' your final orbital altitude one way
or the other.  This can take a bit of practice and judgement (or just an
intuitive understanding of the underlying dynamics) to get right, though.
And remember to keep an eye on Burnout time!
